# Digital signatures
How does one prove that a file (or some buffer) was generated by a well-known entity, and not tampered?  
In the physical (human) world, we sign checks and contracts, but those can easily be forged.  
In this blogpost, we're going to explore the main ideas behind digital signatures.  
At this point, we've had quite a few cryptography blogposts already, I will be heavily relying on my previous [RSA](https://github.com/yo-yo-yo-jbo/rsa_math/) and [ECC](https://github.com/yo-yo-yo-jbo/ecc_intro/) blogposts.

## High-level ideas
We refer to the contents of a file or a buffer that we wish to sign as a *message*.  
The idea is to concatenate something to the message - that "something" is called a *signature*.  
In addition, we will be relying on the idea of public and private keys - the concept is explained in my [RSA](https://github.com/yo-yo-yo-jbo/rsa_math/) blogpost.  
Thus:
- We want to create a procedure that gets a *message* and a *private key* and generates a *signature*, and we call this procedure `sign`.
- We want to create a procedure that gets a *message* and a *signature*, and uses a *public key* (assumed at this point to be trusted) that validates the signature indeed correctly signs the message. We will call that procedure `verify`.

In this blogpost, I will be sharing two methods commonly used to sign messages: one with `RSA` and one with Elliptic Curves.

## Digital signatures with RSA
As a reminder, in `RSA` we have a *private key* we refer to as `d`, and a *public key* we refer to as `e`.  
Those are two numbers that "magically" (mathematically, really) ensure that $(m^d)^e = m (mod n)$ for a message `m` (within a certain range).  
Usually, we use the private key for *encryption* and public key for *decryption*, but note we can do it the other way around:  $(m^d)^e = (m^e)^d (mod n)$.  
Therefore, if we have a message `m`, we could sign it like this: $m^d (mod n)$, thus creating the message `m || sign(m)`.  
The receiver cannot easily derive `d` from the signature, but there are some issues with that approach:
1. The message `m` cannot be arbitrarily long - since we treat it as a number, it must be strictly lower than `n` (commonly 4096 bits).
2. There is a *multiplication* issue - assuming two messages `m1` and `m2`, an attacker could sign their multiplication: $sign(m_1 \cdot m_2) = m_1^d \cdot m_2^d = sign(m_1) \cdot sign(m_2)$! Note the attacker only needed to collect the signatures, and *does not know the private key*.

### Using Cryptographic hash functions
To deal with those issues (and others), we use a *cryptographic hash function*, which we will mark as `h` and is assumed to be a one-way-function:
- The function `h` is easy to compute for an arbitrary input - calculating $h(x)$ should not be computationally expensive.
- The function `h` is hard to reverse - given a value `y`, it's hard to find an `x` such that $h(x) = y$.
- It's hard to collide function `h` - given $h(x)$, it's hard to find `y` different than `x` such that $h(x) = h(y)$.
- The output of function `h` has a constant output size for all inputs.

The last point might seem contradictory to the collision requirement - we have infinite numbers of inputs and only a finite set of outputs, which [guarantees](https://en.wikipedia.org/wiki/Pigeonhole_principle) that collisions exist.  
However, the collision requirement discusses *complexity* rather than impossibility - i.e. practically it'd take a lot of computation power to find a collision.  
An example of a hash function used these days is [SHA2](https://en.wikipedia.org/wiki/SHA-2). I might one day write about the inner workings of the `SHA` hash function family.

### Signing and verifying
Armed with the knowledge of cryptographic hash functions, let us slightly redesign our signing algorithm - instead of signing `m`, we will sign the hash of `m`!  
The verifier could then use our public key and get the hash of the signature. After that - the verifier cannot undo the hashing (it's supposed to be a hard problem!) but rather than that - hash `m` and compare.  
Let's code that! Note we will have to convert data from bytes to numbers and back. Here's what I coded:

```python
import hashlib

def sign(d, n, m):
    """
        Signs message m with the private key (d, n).
    """

    # Hash the message and convert the hash to a number
    hash_val = hashlib.sha256(m).digest()
    hash_val = int.from_bytes(hash_val, byteorder='little')

    # Create the signature and convert it into bytes
    signature = pow(hash_val, d, n)
    signature = signature.to_bytes(length=n.bit_length() // 8, byteorder='little')

    # Return signature
    return signature

def verify(e, n, m, signature):
    """
        Verifies the message m with the given signature and the public key (e, n).
    """

    # Convert signature to a number
    signature_val = int.from_bytes(signature, byteorder='little')

    # Decrypt the signature with the public key
    alleged_hash_val = pow(signature_val, e, n)

    # Hash the message and convert it into a number
    hashed_message = hashlib.sha256(m).digest()
    hashed_message_val = int.from_bytes(hashed_message, byteorder='little')

    # Compare the two
    return alleged_hash_val == hashed_message_val
```

Don't believe me? Test it!  
You can easily generate an `RSA` keypair and sign an arbitrary message.

## ECDSA
Moving on, we could use Elliptic Curves for digital signatures!  
That method is known as [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm) and relies on the Discrete Logarithm problem on Elliptic Curves.  
Unlike the `RSA` approach - here's it's more complicated. Let's understand why (hand wavy):
- In `RSA`, encryption and decryption use the same operation - we work by exponentiation over large numbers in a large finite Field. We say that the exponantiation operation is *Commutative* - and use that to our advantage.
- In Elliptic Curves, our private key is very different from our public key - our private key is a scalar, but our public key is a point on a curve! We do not have a similar Commutative operation - for example, if our private key is `d` (with a generator point `G`), we can create a public key `dG` but we cannot share a magical $d^{-1}$ without revealing the private key!
- One more reason is that hash values are not points on a curve. We can certainly turn an arbitrary hash value into a point, but it's an extra step.

So, for that, we will need something more sophisticated. The main idea is creating a random *epehemral nonce* and generate another point with it.  
That point will then be combined in some way with the hash function, as well as proving that the way it was used requires for the signer to know the (long-term) private key.  
Instead of using further words, let's describe the algorithm and then explain why it's correct.

### Signing with ECDSA
Setting the state, we assume the signer has a private key `d`, as well as a public key `Q = dG` that is "trusted" by the verifier.  
The verifier also knows the curve domain parameters (generator `G`, modulus `n`, the curve equation itself and so on).  
To sign a message `m`, we do the following:
1. Use a hash function to get `z = hash(m)`. If `z` has more bits than the bit length of `n` - we trim it down, assuming the hash function is still good enough even after truncation.
2. We get a random number `k` between `1` and `n-1` - that will be our epehemeral nonce. It's important it's randomly generated for *every* signature (more on that - later).
3. We now calculate a corresponding public epehemeral key: `R = kG`. We mark `r` as the `x` coordinate of `R` and make sure it's not 0 (if it is, we randomize a new `k` and retry).
4. We calculate: $s = k^{-1}(z + rd)$. Note `s` is a scalar and $k^{-1}$ is the multiplicative inverse of `k (mod n)`.
5. The signature is `(r, s)`.

### Verification wih ECDSA
Similarly to the signing process, we assume the verifier knows the curve domain parameters, as well as the public key `Q`.  
Obviously verifier does not know the private key `d` or the ephemeral nonce `k`.  
Verfier gets a signature `(r, s)` and does the following:
1. Verify that `r` and `s` from the signature are scalars in the range `1 .. (n-1)`.
2. Use a hash function to get `z = hash(m)`. If `z` and truncate if it's too large.
3. Calculate $u_1 = zs^{-1} (mod n)$ (using modular inverse [Euclidean Algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm) that I have [described in the past](https://github.com/yo-yo-yo-jbo/crypto_modular/)).
4. Calculate $u_2 = rs^{-1} (mod n)$ similarly.
5. Calculate a new point: $R = u_1G + u_2Q$, and validate the resulting point `R` is not the point at infinity $\mathcal{O}$.
6. Check the signature - compare the `x` coodinate of `R` to `r` - if they are equal, we consider the signature valid.




