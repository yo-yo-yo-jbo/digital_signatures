# Digital signatures
How does one prove that a file (or some buffer) was generated by a well-known entity, and not tampered?  
In the physical (human) world, we sign checks and contracts, but those can easily be forged.  
In this blogpost, we're going to explore the main ideas behind digital signatures.  
At this point, we've had quite a few cryptography blogposts already, I will be heavily relying on my previous [RSA](https://github.com/yo-yo-yo-jbo/rsa_math/) and [ECC](https://github.com/yo-yo-yo-jbo/ecc_intro/) blogposts.

## High-level design
We refer to the contents of a file or a buffer that we wish to sign as a *message*.  
The idea is to concatenate something to the message - that "something" is called a *signature*.  
In addition, we will be relying on the idea of public and private keys - the concept is explained in my [RSA](https://github.com/yo-yo-yo-jbo/rsa_math/) blogpost.  
Thus:
- We want to create a procedure that gets a *message* and a *private key* and generates a *signature*, and we call this procedure `sign`.
- We want to create a procedure that gets a *message* and a *signature*, and uses a *public key* (assumed at this point to be trusted) that validates the signature indeed correctly signs the message. We will call that procedure `verify`.

In this blogpost, I will be sharing two methods commonly used to sign messages: one with `RSA` and one with Elliptic Curves.

## Digital signatures with RSA
